{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='rosaControlPlane', url='', help='"ROSAControlPlane is the Schema for the ROSAControlPlanes API."'),
  '#metadata':: d.obj(help='"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create."'),
  metadata: {
    '#withAnnotations':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { metadata+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
    '#withClusterName':: d.fn(help='"The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request."', args=[d.arg(name='clusterName', type=d.T.string)]),
    withClusterName(clusterName): { metadata+: { clusterName: clusterName } },
    '#withCreationTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='creationTimestamp', type=d.T.string)]),
    withCreationTimestamp(creationTimestamp): { metadata+: { creationTimestamp: creationTimestamp } },
    '#withDeletionGracePeriodSeconds':: d.fn(help='"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only."', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.integer)]),
    withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } },
    '#withDeletionTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='deletionTimestamp', type=d.T.string)]),
    withDeletionTimestamp(deletionTimestamp): { metadata+: { deletionTimestamp: deletionTimestamp } },
    '#withFinalizers':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withFinalizersMixin':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withGenerateName':: d.fn(help='"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\\n\\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\\n\\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"', args=[d.arg(name='generateName', type=d.T.string)]),
    withGenerateName(generateName): { metadata+: { generateName: generateName } },
    '#withGeneration':: d.fn(help='"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only."', args=[d.arg(name='generation', type=d.T.integer)]),
    withGeneration(generation): { metadata+: { generation: generation } },
    '#withLabels':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { metadata+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { metadata+: { labels+: labels } },
    '#withName':: d.fn(help='"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names"', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { metadata+: { name: name } },
    '#withNamespace':: d.fn(help='"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \\"default\\" namespace, but \\"default\\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\\n\\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces"', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { metadata+: { namespace: namespace } },
    '#withOwnerReferences':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferences(ownerReferences): { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withOwnerReferencesMixin':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferencesMixin(ownerReferences): { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withResourceVersion':: d.fn(help='"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\\n\\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
    withResourceVersion(resourceVersion): { metadata+: { resourceVersion: resourceVersion } },
    '#withSelfLink':: d.fn(help='"SelfLink is a URL representing this object. Populated by the system. Read-only.\\n\\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release."', args=[d.arg(name='selfLink', type=d.T.string)]),
    withSelfLink(selfLink): { metadata+: { selfLink: selfLink } },
    '#withUid':: d.fn(help='"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\\n\\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids"', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { metadata+: { uid: uid } },
  },
  '#new':: d.fn(help='new returns an instance of ROSAControlPlane', args=[d.arg(name='name', type=d.T.string)]),
  new(name): {
    apiVersion: 'controlplane.cluster.x-k8s.io/v1beta2',
    kind: 'ROSAControlPlane',
  } + self.metadata.withName(name=name),
  '#spec':: d.obj(help='"RosaControlPlaneSpec defines the desired state of ROSAControlPlane."'),
  spec: {
    '#clusterRegistryConfig':: d.obj(help='"ClusterRegistryConfig represents registry config used with the cluster."'),
    clusterRegistryConfig: {
      '#allowedRegistriesForImport':: d.obj(help='"AllowedRegistriesForImport limits the container image registries that normal users may import\\nimages from. Set this list to the registries that you trust to contain valid Docker\\nimages and that you want applications to be able to import from."'),
      allowedRegistriesForImport: {
        '#withDomainName':: d.fn(help="\"domainName specifies a domain name for the registry. The domain name might include wildcards, like '*' or '??'.\\nIn case the registry use non-standard (80 or 443) port, the port should be included in the domain name as well.\"", args=[d.arg(name='domainName', type=d.T.string)]),
        withDomainName(domainName): { domainName: domainName },
        '#withInsecure':: d.fn(help='"insecure indicates whether the registry is secure (https) or insecure (http), default is secured."', args=[d.arg(name='insecure', type=d.T.boolean)]),
        withInsecure(insecure): { insecure: insecure },
      },
      '#registrySources':: d.obj(help='"RegistrySources contains configuration that determines how the container runtime\\nshould treat individual registries when accessing images. It does not contain configuration\\nfor the internal cluster registry. AllowedRegistries, BlockedRegistries are mutually exclusive."'),
      registrySources: {
        '#withAllowedRegistries':: d.fn(help='"AllowedRegistries are the registries for which image pull and push actions are allowed.\\nTo specify all subdomains, add the asterisk (*) wildcard character as a prefix to the domain name,\\nFor example, *.example.com.\\nYou can specify an individual repository within a registry, For example: reg1.io/myrepo/myapp:latest.\\nAll other registries are blocked."', args=[d.arg(name='allowedRegistries', type=d.T.array)]),
        withAllowedRegistries(allowedRegistries): { spec+: { clusterRegistryConfig+: { registrySources+: { allowedRegistries: if std.isArray(v=allowedRegistries) then allowedRegistries else [allowedRegistries] } } } },
        '#withAllowedRegistriesMixin':: d.fn(help='"AllowedRegistries are the registries for which image pull and push actions are allowed.\\nTo specify all subdomains, add the asterisk (*) wildcard character as a prefix to the domain name,\\nFor example, *.example.com.\\nYou can specify an individual repository within a registry, For example: reg1.io/myrepo/myapp:latest.\\nAll other registries are blocked."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='allowedRegistries', type=d.T.array)]),
        withAllowedRegistriesMixin(allowedRegistries): { spec+: { clusterRegistryConfig+: { registrySources+: { allowedRegistries+: if std.isArray(v=allowedRegistries) then allowedRegistries else [allowedRegistries] } } } },
        '#withBlockedRegistries':: d.fn(help='"BlockedRegistries are the registries for which image pull and push actions are denied.\\nTo specify all subdomains, add the asterisk (*) wildcard character as a prefix to the domain name,\\nFor example, *.example.com.\\nYou can specify an individual repository within a registry, For example: reg1.io/myrepo/myapp:latest.\\nAll other registries are allowed."', args=[d.arg(name='blockedRegistries', type=d.T.array)]),
        withBlockedRegistries(blockedRegistries): { spec+: { clusterRegistryConfig+: { registrySources+: { blockedRegistries: if std.isArray(v=blockedRegistries) then blockedRegistries else [blockedRegistries] } } } },
        '#withBlockedRegistriesMixin':: d.fn(help='"BlockedRegistries are the registries for which image pull and push actions are denied.\\nTo specify all subdomains, add the asterisk (*) wildcard character as a prefix to the domain name,\\nFor example, *.example.com.\\nYou can specify an individual repository within a registry, For example: reg1.io/myrepo/myapp:latest.\\nAll other registries are allowed."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='blockedRegistries', type=d.T.array)]),
        withBlockedRegistriesMixin(blockedRegistries): { spec+: { clusterRegistryConfig+: { registrySources+: { blockedRegistries+: if std.isArray(v=blockedRegistries) then blockedRegistries else [blockedRegistries] } } } },
        '#withInsecureRegistries':: d.fn(help='"InsecureRegistries are registries which do not have a valid TLS certificate or only support HTTP connections.\\nTo specify all subdomains, add the asterisk (*) wildcard character as a prefix to the domain name,\\nFor example, *.example.com.\\nYou can specify an individual repository within a registry, For example: reg1.io/myrepo/myapp:latest."', args=[d.arg(name='insecureRegistries', type=d.T.array)]),
        withInsecureRegistries(insecureRegistries): { spec+: { clusterRegistryConfig+: { registrySources+: { insecureRegistries: if std.isArray(v=insecureRegistries) then insecureRegistries else [insecureRegistries] } } } },
        '#withInsecureRegistriesMixin':: d.fn(help='"InsecureRegistries are registries which do not have a valid TLS certificate or only support HTTP connections.\\nTo specify all subdomains, add the asterisk (*) wildcard character as a prefix to the domain name,\\nFor example, *.example.com.\\nYou can specify an individual repository within a registry, For example: reg1.io/myrepo/myapp:latest."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='insecureRegistries', type=d.T.array)]),
        withInsecureRegistriesMixin(insecureRegistries): { spec+: { clusterRegistryConfig+: { registrySources+: { insecureRegistries+: if std.isArray(v=insecureRegistries) then insecureRegistries else [insecureRegistries] } } } },
      },
      '#withAdditionalTrustedCAs':: d.fn(help='"AdditionalTrustedCAs containing the registry hostname as the key, and the PEM-encoded certificate as the value,\\nfor each additional registry CA to trust."', args=[d.arg(name='additionalTrustedCAs', type=d.T.object)]),
      withAdditionalTrustedCAs(additionalTrustedCAs): { spec+: { clusterRegistryConfig+: { additionalTrustedCAs: additionalTrustedCAs } } },
      '#withAdditionalTrustedCAsMixin':: d.fn(help='"AdditionalTrustedCAs containing the registry hostname as the key, and the PEM-encoded certificate as the value,\\nfor each additional registry CA to trust."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='additionalTrustedCAs', type=d.T.object)]),
      withAdditionalTrustedCAsMixin(additionalTrustedCAs): { spec+: { clusterRegistryConfig+: { additionalTrustedCAs+: additionalTrustedCAs } } },
      '#withAllowedRegistriesForImport':: d.fn(help='"AllowedRegistriesForImport limits the container image registries that normal users may import\\nimages from. Set this list to the registries that you trust to contain valid Docker\\nimages and that you want applications to be able to import from."', args=[d.arg(name='allowedRegistriesForImport', type=d.T.array)]),
      withAllowedRegistriesForImport(allowedRegistriesForImport): { spec+: { clusterRegistryConfig+: { allowedRegistriesForImport: if std.isArray(v=allowedRegistriesForImport) then allowedRegistriesForImport else [allowedRegistriesForImport] } } },
      '#withAllowedRegistriesForImportMixin':: d.fn(help='"AllowedRegistriesForImport limits the container image registries that normal users may import\\nimages from. Set this list to the registries that you trust to contain valid Docker\\nimages and that you want applications to be able to import from."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='allowedRegistriesForImport', type=d.T.array)]),
      withAllowedRegistriesForImportMixin(allowedRegistriesForImport): { spec+: { clusterRegistryConfig+: { allowedRegistriesForImport+: if std.isArray(v=allowedRegistriesForImport) then allowedRegistriesForImport else [allowedRegistriesForImport] } } },
    },
    '#controlPlaneEndpoint':: d.obj(help='"ControlPlaneEndpoint represents the endpoint used to communicate with the control plane."'),
    controlPlaneEndpoint: {
      '#withHost':: d.fn(help='"The hostname on which the API server is serving."', args=[d.arg(name='host', type=d.T.string)]),
      withHost(host): { spec+: { controlPlaneEndpoint+: { host: host } } },
      '#withPort':: d.fn(help='"The port on which the API server is serving."', args=[d.arg(name='port', type=d.T.integer)]),
      withPort(port): { spec+: { controlPlaneEndpoint+: { port: port } } },
    },
    '#credentialsSecretRef':: d.obj(help="\"CredentialsSecretRef references a secret with necessary credentials to connect to the OCM API.\\nThe secret should contain the following data keys:\\n- ocmToken: eyJhbGciOiJIUzI1NiIsI....\\n- ocmApiUrl: Optional, defaults to 'https://api.openshift.com'\""),
    credentialsSecretRef: {
      '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { credentialsSecretRef+: { name: name } } },
    },
    '#defaultMachinePoolSpec':: d.obj(help='"DefaultMachinePoolSpec defines the configuration for the default machinepool(s) provisioned as part of the cluster creation.\\nOne MachinePool will be created with this configuration per AvailabilityZone. Those default machinepools are required for openshift cluster operators\\nto work properly.\\nAs these machinepool not created using ROSAMachinePool CR, they will not be visible/managed by ROSA CAPI provider.\\n`rosa list machinepools -c <rosaClusterName>` can be used to view those machinepools.\\n\\nThis field will be removed in the future once the current limitation is resolved."'),
    defaultMachinePoolSpec: {
      '#autoscaling':: d.obj(help='"Autoscaling specifies auto scaling behaviour for the default MachinePool. Autoscaling min/max value\\nmust be equal or multiple of the availability zones count."'),
      autoscaling: {
        '#withMaxReplicas':: d.fn(help='', args=[d.arg(name='maxReplicas', type=d.T.integer)]),
        withMaxReplicas(maxReplicas): { spec+: { defaultMachinePoolSpec+: { autoscaling+: { maxReplicas: maxReplicas } } } },
        '#withMinReplicas':: d.fn(help='', args=[d.arg(name='minReplicas', type=d.T.integer)]),
        withMinReplicas(minReplicas): { spec+: { defaultMachinePoolSpec+: { autoscaling+: { minReplicas: minReplicas } } } },
      },
      '#withInstanceType':: d.fn(help='"The instance type to use, for example `r5.xlarge`. Instance type ref; https://aws.amazon.com/ec2/instance-types/"', args=[d.arg(name='instanceType', type=d.T.string)]),
      withInstanceType(instanceType): { spec+: { defaultMachinePoolSpec+: { instanceType: instanceType } } },
      '#withVolumeSize':: d.fn(help='"VolumeSize set the disk volume size for the default workers machine pool in Gib. The default is 300 GiB."', args=[d.arg(name='volumeSize', type=d.T.integer)]),
      withVolumeSize(volumeSize): { spec+: { defaultMachinePoolSpec+: { volumeSize: volumeSize } } },
    },
    '#externalAuthProviders':: d.obj(help='"ExternalAuthProviders are external OIDC identity providers that can issue tokens for this cluster.\\nCan only be set if \\"enableExternalAuthProviders\\" is set to \\"True\\".\\n\\nAt most one provider can be configured."'),
    externalAuthProviders: {
      '#claimMappings':: d.obj(help='"ClaimMappings describes rules on how to transform information from an\\nID token into a cluster identity"'),
      claimMappings: {
        '#groups':: d.obj(help='"Groups is a name of the claim that should be used to construct\\ngroups for the cluster identity.\\nThe referenced claim must use array of strings values."'),
        groups: {
          '#withClaim':: d.fn(help='"Claim is a JWT token claim to be used in the mapping"', args=[d.arg(name='claim', type=d.T.string)]),
          withClaim(claim): { claimMappings+: { groups+: { claim: claim } } },
          '#withPrefix':: d.fn(help='"Prefix is a string to prefix the value from the token in the result of the\\nclaim mapping.\\n\\nBy default, no prefixing occurs.\\n\\nExample: if `prefix` is set to \\"myoidc:\\"\\" and the `claim` in JWT contains\\nan array of strings \\"a\\", \\"b\\" and  \\"c\\", the mapping will result in an\\narray of string \\"myoidc:a\\", \\"myoidc:b\\" and \\"myoidc:c\\"."', args=[d.arg(name='prefix', type=d.T.string)]),
          withPrefix(prefix): { claimMappings+: { groups+: { prefix: prefix } } },
        },
        '#username':: d.obj(help='"Username is a name of the claim that should be used to construct\\nusernames for the cluster identity.\\n\\nDefault value: \\"sub\\'),
        username: {
          '#withClaim':: d.fn(help='"Claim is a JWT token claim to be used in the mapping"', args=[d.arg(name='claim', type=d.T.string)]),
          withClaim(claim): { claimMappings+: { username+: { claim: claim } } },
          '#withPrefix':: d.fn(help='"Prefix is prepended to claim to prevent clashes with existing names."', args=[d.arg(name='prefix', type=d.T.string)]),
          withPrefix(prefix): { claimMappings+: { username+: { prefix: prefix } } },
          '#withPrefixPolicy':: d.fn(help='"PrefixPolicy specifies how a prefix should apply.\\n\\nBy default, claims other than `email` will be prefixed with the issuer URL to\\nprevent naming clashes with other plugins.\\n\\nSet to \\"NoPrefix\\" to disable prefixing.\\n\\nExample:\\n    (1) `prefix` is set to \\"myoidc:\\" and `claim` is set to \\"username\\".\\n        If the JWT claim `username` contains value `userA`, the resulting\\n        mapped value will be \\"myoidc:userA\\".\\n    (2) `prefix` is set to \\"myoidc:\\" and `claim` is set to \\"email\\". If the\\n        JWT `email` claim contains value \\"userA@myoidc.tld\\", the resulting\\n        mapped value will be \\"myoidc:userA@myoidc.tld\\".\\n    (3) `prefix` is unset, `issuerURL` is set to `https://myoidc.tld`,\\n        the JWT claims include \\"username\\":\\"userA\\" and \\"email\\":\\"userA@myoidc.tld\\",\\n        and `claim` is set to:\\n        (a) \\"username\\": the mapped value will be \\"https://myoidc.tld#userA\\"\\n        (b) \\"email\\": the mapped value will be \\"userA@myoidc.tld\\', args=[d.arg(name='prefixPolicy', type=d.T.string)]),
          withPrefixPolicy(prefixPolicy): { claimMappings+: { username+: { prefixPolicy: prefixPolicy } } },
        },
      },
      '#claimValidationRules':: d.obj(help='"ClaimValidationRules are rules that are applied to validate token claims to authenticate users."'),
      claimValidationRules: {
        '#requiredClaim':: d.obj(help='"RequiredClaim allows configuring a required claim name and its expected value"'),
        requiredClaim: {
          '#withClaim':: d.fn(help='"Claim is a name of a required claim. Only claims with string values are\\nsupported."', args=[d.arg(name='claim', type=d.T.string)]),
          withClaim(claim): { requiredClaim+: { claim: claim } },
          '#withRequiredValue':: d.fn(help='"RequiredValue is the required value for the claim."', args=[d.arg(name='requiredValue', type=d.T.string)]),
          withRequiredValue(requiredValue): { requiredClaim+: { requiredValue: requiredValue } },
        },
        '#withType':: d.fn(help='"Type sets the type of the validation rule"', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { type: type },
      },
      '#issuer':: d.obj(help='"Issuer describes attributes of the OIDC token issuer"'),
      issuer: {
        '#issuerCertificateAuthority':: d.obj(help='"CertificateAuthority is a reference to a config map in the\\nconfiguration namespace. The .data of the configMap must contain\\nthe \\"ca-bundle.crt\\" key.\\nIf unset, system trust is used instead."'),
        issuerCertificateAuthority: {
          '#withName':: d.fn(help='"Name is the metadata.name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { issuer+: { issuerCertificateAuthority+: { name: name } } },
        },
        '#withAudiences':: d.fn(help='"Audiences is an array of audiences that the token was issued for.\\nValid tokens must include at least one of these values in their\\n\\"aud\\" claim.\\nMust be set to exactly one value."', args=[d.arg(name='audiences', type=d.T.array)]),
        withAudiences(audiences): { issuer+: { audiences: if std.isArray(v=audiences) then audiences else [audiences] } },
        '#withAudiencesMixin':: d.fn(help='"Audiences is an array of audiences that the token was issued for.\\nValid tokens must include at least one of these values in their\\n\\"aud\\" claim.\\nMust be set to exactly one value."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='audiences', type=d.T.array)]),
        withAudiencesMixin(audiences): { issuer+: { audiences+: if std.isArray(v=audiences) then audiences else [audiences] } },
        '#withIssuerURL':: d.fn(help='"URL is the serving URL of the token issuer.\\nMust use the https:// scheme."', args=[d.arg(name='issuerURL', type=d.T.string)]),
        withIssuerURL(issuerURL): { issuer+: { issuerURL: issuerURL } },
      },
      '#oidcClients':: d.obj(help="\"OIDCClients contains configuration for the platform's clients that\\nneed to request tokens from the issuer\""),
      oidcClients: {
        '#clientSecret':: d.obj(help='"ClientSecret refers to a secret that\\ncontains the client secret in the `clientSecret` key of the `.data` field"'),
        clientSecret: {
          '#withName':: d.fn(help='"Name is the metadata.name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { clientSecret+: { name: name } },
        },
        '#withClientID':: d.fn(help='"ClientID is the identifier of the OIDC client from the OIDC provider"', args=[d.arg(name='clientID', type=d.T.string)]),
        withClientID(clientID): { clientID: clientID },
        '#withComponentName':: d.fn(help='"ComponentName is the name of the component that is supposed to consume this\\nclient configuration"', args=[d.arg(name='componentName', type=d.T.string)]),
        withComponentName(componentName): { componentName: componentName },
        '#withComponentNamespace':: d.fn(help='"ComponentNamespace is the namespace of the component that is supposed to consume this\\nclient configuration"', args=[d.arg(name='componentNamespace', type=d.T.string)]),
        withComponentNamespace(componentNamespace): { componentNamespace: componentNamespace },
        '#withExtraScopes':: d.fn(help='"ExtraScopes is an optional set of scopes to request tokens with."', args=[d.arg(name='extraScopes', type=d.T.array)]),
        withExtraScopes(extraScopes): { extraScopes: if std.isArray(v=extraScopes) then extraScopes else [extraScopes] },
        '#withExtraScopesMixin':: d.fn(help='"ExtraScopes is an optional set of scopes to request tokens with."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='extraScopes', type=d.T.array)]),
        withExtraScopesMixin(extraScopes): { extraScopes+: if std.isArray(v=extraScopes) then extraScopes else [extraScopes] },
      },
      '#withClaimValidationRules':: d.fn(help='"ClaimValidationRules are rules that are applied to validate token claims to authenticate users."', args=[d.arg(name='claimValidationRules', type=d.T.array)]),
      withClaimValidationRules(claimValidationRules): { claimValidationRules: if std.isArray(v=claimValidationRules) then claimValidationRules else [claimValidationRules] },
      '#withClaimValidationRulesMixin':: d.fn(help='"ClaimValidationRules are rules that are applied to validate token claims to authenticate users."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='claimValidationRules', type=d.T.array)]),
      withClaimValidationRulesMixin(claimValidationRules): { claimValidationRules+: if std.isArray(v=claimValidationRules) then claimValidationRules else [claimValidationRules] },
      '#withName':: d.fn(help='"Name of the OIDC provider"', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { name: name },
      '#withOidcClients':: d.fn(help="\"OIDCClients contains configuration for the platform's clients that\\nneed to request tokens from the issuer\"", args=[d.arg(name='oidcClients', type=d.T.array)]),
      withOidcClients(oidcClients): { oidcClients: if std.isArray(v=oidcClients) then oidcClients else [oidcClients] },
      '#withOidcClientsMixin':: d.fn(help="\"OIDCClients contains configuration for the platform's clients that\\nneed to request tokens from the issuer\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='oidcClients', type=d.T.array)]),
      withOidcClientsMixin(oidcClients): { oidcClients+: if std.isArray(v=oidcClients) then oidcClients else [oidcClients] },
    },
    '#identityRef':: d.obj(help='"IdentityRef is a reference to an identity to be used when reconciling the managed control plane.\\nIf no identity is specified, the default identity for this controller will be used."'),
    identityRef: {
      '#withKind':: d.fn(help='"Kind of the identity."', args=[d.arg(name='kind', type=d.T.string)]),
      withKind(kind): { spec+: { identityRef+: { kind: kind } } },
      '#withName':: d.fn(help='"Name of the identity."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { identityRef+: { name: name } } },
    },
    '#network':: d.obj(help='"Network config for the ROSA HCP cluster."'),
    network: {
      '#withHostPrefix':: d.fn(help='"Network host prefix which is defaulted to `23` if not specified."', args=[d.arg(name='hostPrefix', type=d.T.integer)]),
      withHostPrefix(hostPrefix): { spec+: { network+: { hostPrefix: hostPrefix } } },
      '#withMachineCIDR':: d.fn(help='"IP addresses block used by OpenShift while installing the cluster, for example \\"10.0.0.0/16\\"."', args=[d.arg(name='machineCIDR', type=d.T.string)]),
      withMachineCIDR(machineCIDR): { spec+: { network+: { machineCIDR: machineCIDR } } },
      '#withNetworkType':: d.fn(help='"The CNI network type default is OVNKubernetes."', args=[d.arg(name='networkType', type=d.T.string)]),
      withNetworkType(networkType): { spec+: { network+: { networkType: networkType } } },
      '#withPodCIDR':: d.fn(help='"IP address block from which to assign pod IP addresses, for example `10.128.0.0/14`."', args=[d.arg(name='podCIDR', type=d.T.string)]),
      withPodCIDR(podCIDR): { spec+: { network+: { podCIDR: podCIDR } } },
      '#withServiceCIDR':: d.fn(help='"IP address block from which to assign service IP addresses, for example `172.30.0.0/16`."', args=[d.arg(name='serviceCIDR', type=d.T.string)]),
      withServiceCIDR(serviceCIDR): { spec+: { network+: { serviceCIDR: serviceCIDR } } },
    },
    '#rolesRef':: d.obj(help='"AWS IAM roles used to perform credential requests by the openshift operators."'),
    rolesRef: {
      '#withControlPlaneOperatorARN':: d.fn(help='"ControlPlaneOperatorARN  is an ARN value referencing a role appropriate for the Control Plane Operator.\\n\\nThe following is an example of a valid policy document:\\n\\n{\\n\\t\\"Version\\": \\"2012-10-17\\",\\n\\t\\"Statement\\": [\\n\\t\\t{\\n\\t\\t\\t\\"Effect\\": \\"Allow\\",\\n\\t\\t\\t\\"Action\\": [\\n\\t\\t\\t\\t\\"ec2:CreateVpcEndpoint\\",\\n\\t\\t\\t\\t\\"ec2:DescribeVpcEndpoints\\",\\n\\t\\t\\t\\t\\"ec2:ModifyVpcEndpoint\\",\\n\\t\\t\\t\\t\\"ec2:DeleteVpcEndpoints\\",\\n\\t\\t\\t\\t\\"ec2:CreateTags\\",\\n\\t\\t\\t\\t\\"route53:ListHostedZones\\",\\n\\t\\t\\t\\t\\"ec2:CreateSecurityGroup\\",\\n\\t\\t\\t\\t\\"ec2:AuthorizeSecurityGroupIngress\\",\\n\\t\\t\\t\\t\\"ec2:AuthorizeSecurityGroupEgress\\",\\n\\t\\t\\t\\t\\"ec2:DeleteSecurityGroup\\",\\n\\t\\t\\t\\t\\"ec2:RevokeSecurityGroupIngress\\",\\n\\t\\t\\t\\t\\"ec2:RevokeSecurityGroupEgress\\",\\n\\t\\t\\t\\t\\"ec2:DescribeSecurityGroups\\",\\n\\t\\t\\t\\t\\"ec2:DescribeVpcs\\",\\n\\t\\t\\t],\\n\\t\\t\\t\\"Resource\\": \\"*\\"\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\"Effect\\": \\"Allow\\",\\n\\t\\t\\t\\"Action\\": [\\n\\t\\t\\t\\t\\"route53:ChangeResourceRecordSets\\",\\n\\t\\t\\t\\t\\"route53:ListResourceRecordSets\\"\\n\\t\\t\\t],\\n\\t\\t\\t\\"Resource\\": \\"arn:aws:route53:::%s\\"\\n\\t\\t}\\n\\t]\\n}"', args=[d.arg(name='controlPlaneOperatorARN', type=d.T.string)]),
      withControlPlaneOperatorARN(controlPlaneOperatorARN): { spec+: { rolesRef+: { controlPlaneOperatorARN: controlPlaneOperatorARN } } },
      '#withImageRegistryARN':: d.fn(help='"ImageRegistryARN is an ARN value referencing a role appropriate for the Image Registry Operator.\\n\\nThe following is an example of a valid policy document:\\n\\n{\\n\\t\\"Version\\": \\"2012-10-17\\",\\n\\t\\"Statement\\": [\\n\\t\\t{\\n\\t\\t\\t\\"Effect\\": \\"Allow\\",\\n\\t\\t\\t\\"Action\\": [\\n\\t\\t\\t\\t\\"s3:CreateBucket\\",\\n\\t\\t\\t\\t\\"s3:DeleteBucket\\",\\n\\t\\t\\t\\t\\"s3:PutBucketTagging\\",\\n\\t\\t\\t\\t\\"s3:GetBucketTagging\\",\\n\\t\\t\\t\\t\\"s3:PutBucketPublicAccessBlock\\",\\n\\t\\t\\t\\t\\"s3:GetBucketPublicAccessBlock\\",\\n\\t\\t\\t\\t\\"s3:PutEncryptionConfiguration\\",\\n\\t\\t\\t\\t\\"s3:GetEncryptionConfiguration\\",\\n\\t\\t\\t\\t\\"s3:PutLifecycleConfiguration\\",\\n\\t\\t\\t\\t\\"s3:GetLifecycleConfiguration\\",\\n\\t\\t\\t\\t\\"s3:GetBucketLocation\\",\\n\\t\\t\\t\\t\\"s3:ListBucket\\",\\n\\t\\t\\t\\t\\"s3:GetObject\\",\\n\\t\\t\\t\\t\\"s3:PutObject\\",\\n\\t\\t\\t\\t\\"s3:DeleteObject\\",\\n\\t\\t\\t\\t\\"s3:ListBucketMultipartUploads\\",\\n\\t\\t\\t\\t\\"s3:AbortMultipartUpload\\",\\n\\t\\t\\t\\t\\"s3:ListMultipartUploadParts\\"\\n\\t\\t\\t],\\n\\t\\t\\t\\"Resource\\": \\"*\\"\\n\\t\\t}\\n\\t]\\n}"', args=[d.arg(name='imageRegistryARN', type=d.T.string)]),
      withImageRegistryARN(imageRegistryARN): { spec+: { rolesRef+: { imageRegistryARN: imageRegistryARN } } },
      '#withIngressARN':: d.fn(help='"The referenced role must have a trust relationship that allows it to be assumed via web identity.\\nhttps://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_oidc.html.\\nExample:\\n{\\n\\t\\t\\"Version\\": \\"2012-10-17\\",\\n\\t\\t\\"Statement\\": [\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\"Effect\\": \\"Allow\\",\\n\\t\\t\\t\\t\\"Principal\\": {\\n\\t\\t\\t\\t\\t\\"Federated\\": \\"{{ .ProviderARN }}\\"\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\"Action\\": \\"sts:AssumeRoleWithWebIdentity\\",\\n\\t\\t\\t\\t\\"Condition\\": {\\n\\t\\t\\t\\t\\t\\"StringEquals\\": {\\n\\t\\t\\t\\t\\t\\t\\"{{ .ProviderName }}:sub\\": {{ .ServiceAccounts }}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t]\\n\\t}\\n\\nIngressARN is an ARN value referencing a role appropriate for the Ingress Operator.\\n\\nThe following is an example of a valid policy document:\\n\\n{\\n\\t\\"Version\\": \\"2012-10-17\\",\\n\\t\\"Statement\\": [\\n\\t\\t{\\n\\t\\t\\t\\"Effect\\": \\"Allow\\",\\n\\t\\t\\t\\"Action\\": [\\n\\t\\t\\t\\t\\"elasticloadbalancing:DescribeLoadBalancers\\",\\n\\t\\t\\t\\t\\"tag:GetResources\\",\\n\\t\\t\\t\\t\\"route53:ListHostedZones\\"\\n\\t\\t\\t],\\n\\t\\t\\t\\"Resource\\": \\"*\\"\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\t\\"Effect\\": \\"Allow\\",\\n\\t\\t\\t\\"Action\\": [\\n\\t\\t\\t\\t\\"route53:ChangeResourceRecordSets\\"\\n\\t\\t\\t],\\n\\t\\t\\t\\"Resource\\": [\\n\\t\\t\\t\\t\\"arn:aws:route53:::PUBLIC_ZONE_ID\\",\\n\\t\\t\\t\\t\\"arn:aws:route53:::PRIVATE_ZONE_ID\\"\\n\\t\\t\\t]\\n\\t\\t}\\n\\t]\\n}"', args=[d.arg(name='ingressARN', type=d.T.string)]),
      withIngressARN(ingressARN): { spec+: { rolesRef+: { ingressARN: ingressARN } } },
      '#withKmsProviderARN':: d.fn(help='', args=[d.arg(name='kmsProviderARN', type=d.T.string)]),
      withKmsProviderARN(kmsProviderARN): { spec+: { rolesRef+: { kmsProviderARN: kmsProviderARN } } },
      '#withKubeCloudControllerARN':: d.fn(help='"KubeCloudControllerARN is an ARN value referencing a role appropriate for the KCM/KCC.\\nSource: https://cloud-provider-aws.sigs.k8s.io/prerequisites/#iam-policies\\n\\nThe following is an example of a valid policy document:\\n\\n {\\n \\"Version\\": \\"2012-10-17\\",\\n \\"Statement\\": [\\n   {\\n     \\"Action\\": [\\n       \\"autoscaling:DescribeAutoScalingGroups\\",\\n       \\"autoscaling:DescribeLaunchConfigurations\\",\\n       \\"autoscaling:DescribeTags\\",\\n       \\"ec2:DescribeAvailabilityZones\\",\\n       \\"ec2:DescribeInstances\\",\\n       \\"ec2:DescribeImages\\",\\n       \\"ec2:DescribeRegions\\",\\n       \\"ec2:DescribeRouteTables\\",\\n       \\"ec2:DescribeSecurityGroups\\",\\n       \\"ec2:DescribeSubnets\\",\\n       \\"ec2:DescribeVolumes\\",\\n       \\"ec2:CreateSecurityGroup\\",\\n       \\"ec2:CreateTags\\",\\n       \\"ec2:CreateVolume\\",\\n       \\"ec2:ModifyInstanceAttribute\\",\\n       \\"ec2:ModifyVolume\\",\\n       \\"ec2:AttachVolume\\",\\n       \\"ec2:AuthorizeSecurityGroupIngress\\",\\n       \\"ec2:CreateRoute\\",\\n       \\"ec2:DeleteRoute\\",\\n       \\"ec2:DeleteSecurityGroup\\",\\n       \\"ec2:DeleteVolume\\",\\n       \\"ec2:DetachVolume\\",\\n       \\"ec2:RevokeSecurityGroupIngress\\",\\n       \\"ec2:DescribeVpcs\\",\\n       \\"elasticloadbalancing:AddTags\\",\\n       \\"elasticloadbalancing:AttachLoadBalancerToSubnets\\",\\n       \\"elasticloadbalancing:ApplySecurityGroupsToLoadBalancer\\",\\n       \\"elasticloadbalancing:CreateLoadBalancer\\",\\n       \\"elasticloadbalancing:CreateLoadBalancerPolicy\\",\\n       \\"elasticloadbalancing:CreateLoadBalancerListeners\\",\\n       \\"elasticloadbalancing:ConfigureHealthCheck\\",\\n       \\"elasticloadbalancing:DeleteLoadBalancer\\",\\n       \\"elasticloadbalancing:DeleteLoadBalancerListeners\\",\\n       \\"elasticloadbalancing:DescribeLoadBalancers\\",\\n       \\"elasticloadbalancing:DescribeLoadBalancerAttributes\\",\\n       \\"elasticloadbalancing:DetachLoadBalancerFromSubnets\\",\\n       \\"elasticloadbalancing:DeregisterInstancesFromLoadBalancer\\",\\n       \\"elasticloadbalancing:ModifyLoadBalancerAttributes\\",\\n       \\"elasticloadbalancing:RegisterInstancesWithLoadBalancer\\",\\n       \\"elasticloadbalancing:SetLoadBalancerPoliciesForBackendServer\\",\\n       \\"elasticloadbalancing:AddTags\\",\\n       \\"elasticloadbalancing:CreateListener\\",\\n       \\"elasticloadbalancing:CreateTargetGroup\\",\\n       \\"elasticloadbalancing:DeleteListener\\",\\n       \\"elasticloadbalancing:DeleteTargetGroup\\",\\n       \\"elasticloadbalancing:DeregisterTargets\\",\\n       \\"elasticloadbalancing:DescribeListeners\\",\\n       \\"elasticloadbalancing:DescribeLoadBalancerPolicies\\",\\n       \\"elasticloadbalancing:DescribeTargetGroups\\",\\n       \\"elasticloadbalancing:DescribeTargetHealth\\",\\n       \\"elasticloadbalancing:ModifyListener\\",\\n       \\"elasticloadbalancing:ModifyTargetGroup\\",\\n       \\"elasticloadbalancing:RegisterTargets\\",\\n       \\"elasticloadbalancing:SetLoadBalancerPoliciesOfListener\\",\\n       \\"iam:CreateServiceLinkedRole\\",\\n       \\"kms:DescribeKey\\"\\n     ],\\n     \\"Resource\\": [\\n       \\"*\\"\\n     ],\\n     \\"Effect\\": \\"Allow\\"\\n   }\\n ]\\n}"', args=[d.arg(name='kubeCloudControllerARN', type=d.T.string)]),
      withKubeCloudControllerARN(kubeCloudControllerARN): { spec+: { rolesRef+: { kubeCloudControllerARN: kubeCloudControllerARN } } },
      '#withNetworkARN':: d.fn(help='"NetworkARN is an ARN value referencing a role appropriate for the Network Operator.\\n\\nThe following is an example of a valid policy document:\\n\\n{\\n\\t\\"Version\\": \\"2012-10-17\\",\\n\\t\\"Statement\\": [\\n\\t\\t{\\n\\t\\t\\t\\"Effect\\": \\"Allow\\",\\n\\t\\t\\t\\"Action\\": [\\n\\t\\t\\t\\t\\"ec2:DescribeInstances\\",\\n       \\"ec2:DescribeInstanceStatus\\",\\n       \\"ec2:DescribeInstanceTypes\\",\\n       \\"ec2:UnassignPrivateIpAddresses\\",\\n       \\"ec2:AssignPrivateIpAddresses\\",\\n       \\"ec2:UnassignIpv6Addresses\\",\\n       \\"ec2:AssignIpv6Addresses\\",\\n       \\"ec2:DescribeSubnets\\",\\n       \\"ec2:DescribeNetworkInterfaces\\"\\n\\t\\t\\t],\\n\\t\\t\\t\\"Resource\\": \\"*\\"\\n\\t\\t}\\n\\t]\\n}"', args=[d.arg(name='networkARN', type=d.T.string)]),
      withNetworkARN(networkARN): { spec+: { rolesRef+: { networkARN: networkARN } } },
      '#withNodePoolManagementARN':: d.fn(help='"NodePoolManagementARN is an ARN value referencing a role appropriate for the CAPI Controller.\\n\\nThe following is an example of a valid policy document:\\n\\n{\\n  \\"Version\\": \\"2012-10-17\\",\\n \\"Statement\\": [\\n   {\\n     \\"Action\\": [\\n       \\"ec2:AssociateRouteTable\\",\\n       \\"ec2:AttachInternetGateway\\",\\n       \\"ec2:AuthorizeSecurityGroupIngress\\",\\n       \\"ec2:CreateInternetGateway\\",\\n       \\"ec2:CreateNatGateway\\",\\n       \\"ec2:CreateRoute\\",\\n       \\"ec2:CreateRouteTable\\",\\n       \\"ec2:CreateSecurityGroup\\",\\n       \\"ec2:CreateSubnet\\",\\n       \\"ec2:CreateTags\\",\\n       \\"ec2:DeleteInternetGateway\\",\\n       \\"ec2:DeleteNatGateway\\",\\n       \\"ec2:DeleteRouteTable\\",\\n       \\"ec2:DeleteSecurityGroup\\",\\n       \\"ec2:DeleteSubnet\\",\\n       \\"ec2:DeleteTags\\",\\n       \\"ec2:DescribeAccountAttributes\\",\\n       \\"ec2:DescribeAddresses\\",\\n       \\"ec2:DescribeAvailabilityZones\\",\\n       \\"ec2:DescribeImages\\",\\n       \\"ec2:DescribeInstances\\",\\n       \\"ec2:DescribeInternetGateways\\",\\n       \\"ec2:DescribeNatGateways\\",\\n       \\"ec2:DescribeNetworkInterfaces\\",\\n       \\"ec2:DescribeNetworkInterfaceAttribute\\",\\n       \\"ec2:DescribeRouteTables\\",\\n       \\"ec2:DescribeSecurityGroups\\",\\n       \\"ec2:DescribeSubnets\\",\\n       \\"ec2:DescribeVpcs\\",\\n       \\"ec2:DescribeVpcAttribute\\",\\n       \\"ec2:DescribeVolumes\\",\\n       \\"ec2:DetachInternetGateway\\",\\n       \\"ec2:DisassociateRouteTable\\",\\n       \\"ec2:DisassociateAddress\\",\\n       \\"ec2:ModifyInstanceAttribute\\",\\n       \\"ec2:ModifyNetworkInterfaceAttribute\\",\\n       \\"ec2:ModifySubnetAttribute\\",\\n       \\"ec2:RevokeSecurityGroupIngress\\",\\n       \\"ec2:RunInstances\\",\\n       \\"ec2:TerminateInstances\\",\\n       \\"tag:GetResources\\",\\n       \\"ec2:CreateLaunchTemplate\\",\\n       \\"ec2:CreateLaunchTemplateVersion\\",\\n       \\"ec2:DescribeLaunchTemplates\\",\\n       \\"ec2:DescribeLaunchTemplateVersions\\",\\n       \\"ec2:DeleteLaunchTemplate\\",\\n       \\"ec2:DeleteLaunchTemplateVersions\\"\\n     ],\\n     \\"Resource\\": [\\n       \\"*\\"\\n     ],\\n     \\"Effect\\": \\"Allow\\"\\n   },\\n   {\\n     \\"Condition\\": {\\n       \\"StringLike\\": {\\n         \\"iam:AWSServiceName\\": \\"elasticloadbalancing.amazonaws.com\\"\\n       }\\n     },\\n     \\"Action\\": [\\n       \\"iam:CreateServiceLinkedRole\\"\\n     ],\\n     \\"Resource\\": [\\n       \\"arn:*:iam::*:role/aws-service-role/elasticloadbalancing.amazonaws.com/AWSServiceRoleForElasticLoadBalancing\\"\\n     ],\\n     \\"Effect\\": \\"Allow\\"\\n   },\\n   {\\n     \\"Action\\": [\\n       \\"iam:PassRole\\"\\n     ],\\n     \\"Resource\\": [\\n       \\"arn:*:iam::*:role/*-worker-role\\"\\n     ],\\n     \\"Effect\\": \\"Allow\\"\\n   },\\n\\t  {\\n\\t  \\t\\"Effect\\": \\"Allow\\",\\n\\t  \\t\\"Action\\": [\\n\\t  \\t\\t\\"kms:Decrypt\\",\\n\\t  \\t\\t\\"kms:ReEncrypt\\",\\n\\t  \\t\\t\\"kms:GenerateDataKeyWithoutPlainText\\",\\n\\t  \\t\\t\\"kms:DescribeKey\\"\\n\\t  \\t],\\n\\t  \\t\\"Resource\\": \\"*\\"\\n\\t  },\\n\\t  {\\n\\t  \\t\\"Effect\\": \\"Allow\\",\\n\\t  \\t\\"Action\\": [\\n\\t  \\t\\t\\"kms:CreateGrant\\"\\n\\t  \\t],\\n\\t  \\t\\"Resource\\": \\"*\\",\\n\\t  \\t\\"Condition\\": {\\n\\t  \\t\\t\\"Bool\\": {\\n\\t  \\t\\t\\t\\"kms:GrantIsForAWSResource\\": true\\n\\t  \\t\\t}\\n\\t  \\t}\\n\\t  }\\n ]\\n}"', args=[d.arg(name='nodePoolManagementARN', type=d.T.string)]),
      withNodePoolManagementARN(nodePoolManagementARN): { spec+: { rolesRef+: { nodePoolManagementARN: nodePoolManagementARN } } },
      '#withStorageARN':: d.fn(help='"StorageARN is an ARN value referencing a role appropriate for the Storage Operator.\\n\\nThe following is an example of a valid policy document:\\n\\n{\\n\\t\\"Version\\": \\"2012-10-17\\",\\n\\t\\"Statement\\": [\\n\\t\\t{\\n\\t\\t\\t\\"Effect\\": \\"Allow\\",\\n\\t\\t\\t\\"Action\\": [\\n\\t\\t\\t\\t\\"ec2:AttachVolume\\",\\n\\t\\t\\t\\t\\"ec2:CreateSnapshot\\",\\n\\t\\t\\t\\t\\"ec2:CreateTags\\",\\n\\t\\t\\t\\t\\"ec2:CreateVolume\\",\\n\\t\\t\\t\\t\\"ec2:DeleteSnapshot\\",\\n\\t\\t\\t\\t\\"ec2:DeleteTags\\",\\n\\t\\t\\t\\t\\"ec2:DeleteVolume\\",\\n\\t\\t\\t\\t\\"ec2:DescribeInstances\\",\\n\\t\\t\\t\\t\\"ec2:DescribeSnapshots\\",\\n\\t\\t\\t\\t\\"ec2:DescribeTags\\",\\n\\t\\t\\t\\t\\"ec2:DescribeVolumes\\",\\n\\t\\t\\t\\t\\"ec2:DescribeVolumesModifications\\",\\n\\t\\t\\t\\t\\"ec2:DetachVolume\\",\\n\\t\\t\\t\\t\\"ec2:ModifyVolume\\"\\n\\t\\t\\t],\\n\\t\\t\\t\\"Resource\\": \\"*\\"\\n\\t\\t}\\n\\t]\\n}"', args=[d.arg(name='storageARN', type=d.T.string)]),
      withStorageARN(storageARN): { spec+: { rolesRef+: { storageARN: storageARN } } },
    },
    '#withAdditionalTags':: d.fn(help='"AdditionalTags are user-defined tags to be added on the AWS resources associated with the control plane."', args=[d.arg(name='additionalTags', type=d.T.object)]),
    withAdditionalTags(additionalTags): { spec+: { additionalTags: additionalTags } },
    '#withAdditionalTagsMixin':: d.fn(help='"AdditionalTags are user-defined tags to be added on the AWS resources associated with the control plane."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='additionalTags', type=d.T.object)]),
    withAdditionalTagsMixin(additionalTags): { spec+: { additionalTags+: additionalTags } },
    '#withAuditLogRoleARN':: d.fn(help='"AuditLogRoleARN defines the role that is used to forward audit logs to AWS CloudWatch.\\nIf not set, audit log forwarding is disabled."', args=[d.arg(name='auditLogRoleARN', type=d.T.string)]),
    withAuditLogRoleARN(auditLogRoleARN): { spec+: { auditLogRoleARN: auditLogRoleARN } },
    '#withAvailabilityZones':: d.fn(help='"AvailabilityZones describe AWS AvailabilityZones of the worker nodes.\\nshould match the AvailabilityZones of the provided Subnets.\\na machinepool will be created for each availabilityZone."', args=[d.arg(name='availabilityZones', type=d.T.array)]),
    withAvailabilityZones(availabilityZones): { spec+: { availabilityZones: if std.isArray(v=availabilityZones) then availabilityZones else [availabilityZones] } },
    '#withAvailabilityZonesMixin':: d.fn(help='"AvailabilityZones describe AWS AvailabilityZones of the worker nodes.\\nshould match the AvailabilityZones of the provided Subnets.\\na machinepool will be created for each availabilityZone."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='availabilityZones', type=d.T.array)]),
    withAvailabilityZonesMixin(availabilityZones): { spec+: { availabilityZones+: if std.isArray(v=availabilityZones) then availabilityZones else [availabilityZones] } },
    '#withBillingAccount':: d.fn(help='"BillingAccount is an optional AWS account to use for billing the subscription fees for ROSA HCP clusters.\\nThe cost of running each ROSA HCP cluster will be billed to the infrastructure account in which the cluster\\nis running."', args=[d.arg(name='billingAccount', type=d.T.string)]),
    withBillingAccount(billingAccount): { spec+: { billingAccount: billingAccount } },
    '#withChannelGroup':: d.fn(help='"OpenShift version channel group, default is stable."', args=[d.arg(name='channelGroup', type=d.T.string)]),
    withChannelGroup(channelGroup): { spec+: { channelGroup: channelGroup } },
    '#withDomainPrefix':: d.fn(help="\"DomainPrefix is an optional prefix added to the cluster's domain name. It will be used\\nwhen generating a sub-domain for the cluster on openshiftapps domain. It must be valid DNS-1035 label\\nconsisting of lower case alphanumeric characters or '-', start with an alphabetic character\\nend with an alphanumeric character and have a max length of 15 characters.\"", args=[d.arg(name='domainPrefix', type=d.T.string)]),
    withDomainPrefix(domainPrefix): { spec+: { domainPrefix: domainPrefix } },
    '#withEnableExternalAuthProviders':: d.fn(help='"EnableExternalAuthProviders enables external authentication configuration for the cluster."', args=[d.arg(name='enableExternalAuthProviders', type=d.T.boolean)]),
    withEnableExternalAuthProviders(enableExternalAuthProviders): { spec+: { enableExternalAuthProviders: enableExternalAuthProviders } },
    '#withEndpointAccess':: d.fn(help='"EndpointAccess specifies the publishing scope of cluster endpoints. The\\ndefault is Public."', args=[d.arg(name='endpointAccess', type=d.T.string)]),
    withEndpointAccess(endpointAccess): { spec+: { endpointAccess: endpointAccess } },
    '#withEtcdEncryptionKMSARN':: d.fn(help='"EtcdEncryptionKMSARN is the ARN of the KMS key used to encrypt etcd. The key itself needs to be\\ncreated out-of-band by the user and tagged with `red-hat:true`."', args=[d.arg(name='etcdEncryptionKMSARN', type=d.T.string)]),
    withEtcdEncryptionKMSARN(etcdEncryptionKMSARN): { spec+: { etcdEncryptionKMSARN: etcdEncryptionKMSARN } },
    '#withExternalAuthProviders':: d.fn(help='"ExternalAuthProviders are external OIDC identity providers that can issue tokens for this cluster.\\nCan only be set if \\"enableExternalAuthProviders\\" is set to \\"True\\".\\n\\nAt most one provider can be configured."', args=[d.arg(name='externalAuthProviders', type=d.T.array)]),
    withExternalAuthProviders(externalAuthProviders): { spec+: { externalAuthProviders: if std.isArray(v=externalAuthProviders) then externalAuthProviders else [externalAuthProviders] } },
    '#withExternalAuthProvidersMixin':: d.fn(help='"ExternalAuthProviders are external OIDC identity providers that can issue tokens for this cluster.\\nCan only be set if \\"enableExternalAuthProviders\\" is set to \\"True\\".\\n\\nAt most one provider can be configured."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='externalAuthProviders', type=d.T.array)]),
    withExternalAuthProvidersMixin(externalAuthProviders): { spec+: { externalAuthProviders+: if std.isArray(v=externalAuthProviders) then externalAuthProviders else [externalAuthProviders] } },
    '#withInstallerRoleARN':: d.fn(help='"InstallerRoleARN is an AWS IAM role that OpenShift Cluster Manager will assume to create the cluster.."', args=[d.arg(name='installerRoleARN', type=d.T.string)]),
    withInstallerRoleARN(installerRoleARN): { spec+: { installerRoleARN: installerRoleARN } },
    '#withOidcID':: d.fn(help='"The ID of the internal OpenID Connect Provider."', args=[d.arg(name='oidcID', type=d.T.string)]),
    withOidcID(oidcID): { spec+: { oidcID: oidcID } },
    '#withProvisionShardID':: d.fn(help='"ProvisionShardID defines the shard where ROSA hosted control plane components will be hosted."', args=[d.arg(name='provisionShardID', type=d.T.string)]),
    withProvisionShardID(provisionShardID): { spec+: { provisionShardID: provisionShardID } },
    '#withRegion':: d.fn(help='"The AWS Region the cluster lives in."', args=[d.arg(name='region', type=d.T.string)]),
    withRegion(region): { spec+: { region: region } },
    '#withRosaClusterName':: d.fn(help="\"Cluster name must be valid DNS-1035 label, so it must consist of lower case alphanumeric\\ncharacters or '-', start with an alphabetic character, end with an alphanumeric character\\nand have a max length of 54 characters.\"", args=[d.arg(name='rosaClusterName', type=d.T.string)]),
    withRosaClusterName(rosaClusterName): { spec+: { rosaClusterName: rosaClusterName } },
    '#withSubnets':: d.fn(help='"The Subnet IDs to use when installing the cluster.\\nSubnetIDs should come in pairs; two per availability zone, one private and one public."', args=[d.arg(name='subnets', type=d.T.array)]),
    withSubnets(subnets): { spec+: { subnets: if std.isArray(v=subnets) then subnets else [subnets] } },
    '#withSubnetsMixin':: d.fn(help='"The Subnet IDs to use when installing the cluster.\\nSubnetIDs should come in pairs; two per availability zone, one private and one public."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='subnets', type=d.T.array)]),
    withSubnetsMixin(subnets): { spec+: { subnets+: if std.isArray(v=subnets) then subnets else [subnets] } },
    '#withSupportRoleARN':: d.fn(help='"SupportRoleARN is an AWS IAM role used by Red Hat SREs to enable\\naccess to the cluster account in order to provide support."', args=[d.arg(name='supportRoleARN', type=d.T.string)]),
    withSupportRoleARN(supportRoleARN): { spec+: { supportRoleARN: supportRoleARN } },
    '#withVersion':: d.fn(help='"OpenShift semantic version, for example \\"4.14.5\\"."', args=[d.arg(name='version', type=d.T.string)]),
    withVersion(version): { spec+: { version: version } },
    '#withVersionGate':: d.fn(help='"VersionGate requires acknowledgment when upgrading ROSA-HCP y-stream versions (e.g., from 4.15 to 4.16).\\nDefault is WaitForAcknowledge.\\nWaitForAcknowledge: If acknowledgment is required, the upgrade will not proceed until VersionGate is set to Acknowledge or AlwaysAcknowledge.\\nAcknowledge: If acknowledgment is required, apply it for the upgrade. After upgrade is done set the version gate to WaitForAcknowledge.\\nAlwaysAcknowledge: If acknowledgment is required, apply it and proceed with the upgrade."', args=[d.arg(name='versionGate', type=d.T.string)]),
    withVersionGate(versionGate): { spec+: { versionGate: versionGate } },
    '#withWorkerRoleARN':: d.fn(help='"WorkerRoleARN is an AWS IAM role that will be attached to worker instances."', args=[d.arg(name='workerRoleARN', type=d.T.string)]),
    withWorkerRoleARN(workerRoleARN): { spec+: { workerRoleARN: workerRoleARN } },
  },
  '#mixin': 'ignore',
  mixin: self,
}
